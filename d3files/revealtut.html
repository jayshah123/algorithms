<html>
<head>
	<meta charset="utf-8">
    <title>Reveal.js 3 Slide Demo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="stylesheet" href="reveal.js-master/css/reveal.min.css">
	   <link rel="stylesheet" href="reveal.js-master/js/highlight.js/styles/monokai.css">
 
    <link rel="stylesheet" href="reveal.js-master/css/theme/serif.css" id="theme">
 
    <script src="reveal.js-master/js/highlight.js/highlight.pack.js"></script>
	<script>
			document.write( '<link rel="stylesheet" href="reveal.js-master/css/print/pdf.css" type="text/css" media="print">' );
	</script>
    <!--Add support for earlier versions of Internet Explorer -->
    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
</head>
<body>
   <!-- Wrap the entire slide show in a div using the "reveal" class. -->
    <div class="reveal">
        <!-- Wrap all slides in a single "slides" class -->
        <div class="slides">
 
            <!-- ALL SLIDES GO HERE -->
            <!-- Each section element contains an individual slide -->
            <section>
                <h1>JAVA</h1>
				
            </section>
			
			<section>
			<h2>In this talk...</h2>
			<p class="fragment roll-in"> Naming conventions </p>
			<p class="fragment roll-in"> Control flow </p>
			<p class="fragment roll-in"> Access Modifiers </p>
			<p class="fragment roll-in"> Interfaces </p>
			<p class="fragment roll-in"> Inheritance </p>
			<p class="fragment roll-in"> Overriding and Overloading</p>
			<p class="fragment roll-in"> Inner Classes and Enums </p>
			</section>

            <section>
                <h2>Java Naming Conventions</h2>
                <ul>
                <p class="fragment roll-in"> Capitals for Classnames and Interfaces,<br/> </p>
                 <p class="fragment roll-in">   camelCase for variables and methods<br /> </p>
                    <p class="fragment roll-in"> ALL_CAPS for Constants </p>
                 </ul>   
                    <br/><br/>
                    <h2>Legal Variables</h2>
                <ul>
                   <p class="fragment roll-in"> Cannot Start with a number!! - 3abc = 100 (Wrong)</p> 
                   <p class="fragment roll-in">Cannot be a keyword - return (Wrong)</p>
                   <p class="fragment roll-in">Are case sensitive - foo and FOO are different</p>
               </ul>
                </p>
            </section>
            
			
			<section>
			<h4>Primitive data types</h4>
			<table cellspacing='0'> <!-- cellspacing='0' is important, must stay -->

	<!-- Table Header -->
	<thead>
		<tr>
			<th>Data Type</th>
			<th>Default value</th>
		</tr>
	</thead>
	<!-- Table Header -->

	<!-- Table Body -->
	<tbody>

		<tr>
			<td>byte</td>
			<td>0</td>
		</tr><!-- Table Row -->

		<tr>
			<td>short</td>
			<td>0</td>
		</tr><!-- Darker Table Row -->

		<tr>
			<td>int</td>
			<td>0</td>
		</tr>

		<tr>
			<td>long</td>
			<td>0L</td>
		</tr>

		<tr>
			<td>float</td>
			<td>0.0f</td>
		</tr>

		<tr>
			<td>double</td>
			<td>0.0d</td>
		</tr>

		<tr>
			<td>char</td>
			<td>'\u0000'</td>
		</tr>

	
		<tr>
			<td>String</td>
			<td>null</td>
		</tr>
		
		
		<tr>
			<td>boolean</td>
			<td>false</td>
		</tr>

	</tbody>
	<!-- Table Body -->

</table>
				
			</section>

			<section>
			3 parts to using an array
			1. decl
			2. new
			3. initialize individual elems
			//code
			</section>
			
            <section> 
                <h3>If else example</h3>
                <pre class="fragment fade-in"><code contenteditable spellcheck="false" class="java">
    if( a &lt b){
        System.out.println("a less than b");
    } else {
        System.out.println("a is greater than or equal to b");
    }

</code></pre>
             </section> 

<section> 
<h3>While example</h3>
<pre class="fragment fade-in"><code contenteditable spellcheck="false" class="java">
    int a = 0;
    while( a &lt 10 ){
        System.out.println("a");
        a++;
    }

</code></pre>
 </section>

<section> 
<h3>do while example</h3>
<pre class="fragment fade-in"><code contenteditable spellcheck="false" class="java">
    int a = 0;
    do{
        System.out.println("a");
    }while( a &lt 10 )

</code></pre>

 </section>

<section> 
<h3>For example</h3>
<pre class="fragment fade-in"><code contenteditable spellcheck="false" class="java">
    int a = 10;
    for( int i = 0 ; i &lt 10 ; i++ ){
        System.out.println("a");
    }

</code></pre>
 <h3>Alternative syntax for collections</h3>
 <pre class="fragment fade-in"><code contenteditable spellcheck="false" class="java">
    String[] arr = {"hello","how","when","where","what","who"};
    for( String str : arr){
        System.out.println(str);
    }

 </code></pre>
 </section>

<section> 
<h3>Switch syntax</h3>
<p>Switch works with primitive, enumerated and String(Java 7)</p>
<pre class="fragment fade-in"><code contenteditable spellcheck="false" class="java">
    int month = 1;
    String monthString;
    switch (month) {
        case 1:  monthString = "January";
             break;
        case 12: monthString = "December";
             break;
        default: monthString = "Invalid month";
             break;
    }

</code></pre>
 </section>

			<section>
			<h3>Source File Declaration Rules</h3>
			<ul>
			<li class="fragment roll-in">There can be only one public class per source code file</li>
			<li class="fragment roll-in">If there is a public class in file, name of file must match it</li>
			<li class="fragment roll-in">A file can have more than one non-public class</li>
			</ul>
			</section>
			
			<section>
			<h3>Understanding packages</h3>
			<h5 class="fragment roll-in">Think of packages like a folders</h5>
			   <pre class="fragment fade-in"><code contenteditable spellcheck="false" class="java">
    package cert;
    public class MyClass { ... }
            </code></pre>
            
            <pre class="fragment fade-in"><code contenteditable spellcheck="false" class="java">
    package cert;
    public class AnotherClass { ... }
            </code></pre>
            
            <pre class="fragment fade-in"><code contenteditable spellcheck="false" class="java">
    package cert;
    public class YetAnotherClass { ... }
            </code></pre>
            
            <p class="fragment roll-in">If you see the directory structure, you will find Myclass.java, AnotherClass.java and YetAnotherClass.java in cert folder</p>
            
			</section>
			
			<section>
			<h2>So what is a class Access? <br /></h2>
			<h4>When I say a Class A has an access to Class B?</h4>
			<p class="fragment roll-in">It means class A can do one of three things:</p>
			<ol>
			<li class="fragment roll-in"> create an instance of class B</li>
			<li class="fragment roll-in"> extend class B</li>
			<li class="fragment roll-in"> Access certain methods and variables within class B</li>
			</ol>
			</section>
			
			<section>
			<h3>Four levels of access</h3>
			<ol>
			<li class="fragment roll-in"> Default Access</li>
			<li class="fragment roll-in"> Public </li>
			<li class="fragment roll-in"> Protected</li>
			<li class="fragment roll-in"> Private</li>
			</ol>
			</section>
			
			<section>
			<h3>Default Access</h3>
			<h5>A class with default access has <em class="fragment highlight-blue">no modifier preceding it</em> in the declaration</h5>
			   <pre class="fragment fade-in"><code contenteditable spellcheck="false" class="java">
    package cert;
    class MyClass { ... }
            </code></pre>
            <p class="fragment fad-in">Same as package level access</p>
            <p class="fragment fad-in">Meaning All the classes in the same package are directly usable
				<pre class="fragment fade-in"><code contenteditable spellcheck="false" class="java">
    package cert;
    class OtherClass { 
        MyClass m = new MyClass();
    }
            </code></pre>
            
            <br/> Classes outside the package are non-existent</p>
			</section>
			
				<section>
			<h3>Public Access</h3>
			<h5>A class with public keyword gives access to all classes in all packages to it </h5>
			   <pre class="fragment fade-in"><code contenteditable spellcheck="false" class="java">
    package cert;
    public class Beverages { ... }
            </code></pre>
            <p class="fragment fad-in">You can use this class in any other packages also.</p>
            <p class="fragment fad-in">But do not forget the import!!</p>
               <pre class="fragment fade-in"><code contenteditable spellcheck="false" class="java">
    package abc;
    import cert.Beverages;
    
    public class Summer { 	
        Beverages b = new Beverages();
    }
            </code></pre>
            
			</section>
			
			<section>
			<h3>Protected and private Access</h3>
			<h5>These kind of classes are usually used inside other classes. Will get back to it soon</h5>
			   <pre class="fragment fade-in"><code contenteditable spellcheck="false" class="java">
    package cert;
   
            </code></pre>
            
			</section>
			
			<section>
			<h2>Java access Matrix</h2>
			<table cellspacing='0'> <!-- cellspacing='0' is important, must stay -->

	<!-- Table Header -->
	<thead>
		<tr>
			<th>Visibility</th>
			<th>Public</th>
			<th>Protected</th>
			<th>Default</th>
			<th>Private</th>
		</tr>
	</thead>
	<!-- Table Header -->

	<!-- Table Body -->
	<tbody>

		<tr class="fragment roll-in">
			<td>From the same class</td>
			<td>Yes</td>
			<td>Yes</td>
			<td>Yes</td>
			<td>Yes</td>
		</tr><!-- Table Row -->

		<tr class="fragment roll-in">
			<td>From any class in the same package</td>
			<td>Yes</td>
			<td>Yes</td>
			<td>Yes</td>
			<td>No</td>
		</tr><!-- Darker Table Row -->

		<tr class="fragment roll-in">
			<td>From a subclass in same package</td>
			<td>Yes</td>
			<td>Yes</td>
			<td>Yes</td>
			<td>No</td>
		</tr>

		<tr class="fragment roll-in">
			<td>From a subclass outside the same package</td>
			<td>Yes</td>
			<td>Yes, thru inheritance</td>
			<td>No</td>
			<td>No</td>
		</tr>

		<tr class="fragment roll-in">
			<td>From any non-subclass class outside the package</td>
			<td>Yes</td>
			<td>No</td>
			<td>No</td>
			<td>No</td>
		
		</tr>

	</tbody>
	<!-- Table Body -->

</table>
			
			</section>
			
			<section>
			<h2>Interfaces in one word</h2>
			<h1 class="fragment roll-in">Contracts!</h1>
			
			</section>
			
			<section>
			<h2>Interfaces</h2>
			    <blockquote class="fragment roll-in"> an interface is a reference type, similar to a class, that can contain only constants, method signatures, and nested types. <br/>There are <b><p class="fragment highlight-red"> no method bodies</p></b>.</blockquote>
				            <pre class="fragment fade-in"><code contenteditable spellcheck="false" class="java">
public interface DoIt {
	void doSomething(int i, double x);
	int doSomethingElse(String s);
}
            </code></pre>
				
			</section>
			
			
			<section>
				<blockquote class="fragment roll-in"> Interfaces cannot be instantiated—they <p class="fragment highlight-red">can only be implemented by classes</p> or extended by other interfaces.</blockquote>
				         <pre class="fragment fade-in"><code contenteditable spellcheck="false" class="java">
public class DoItImpl implements DoIt {
	void doSomething(int i, double x){
		System.out.println("printing i = "+i+" and x = "+x);
	}
	int doSomethingElse(String s){
		System.out.println("String s is "+s);
	}
}
</code></pre>
	
			</section>
			
			<section>
			<h2>Interface = API</h2>
			<p class="fragment roll-in"> APIs are also common in commercial software products.</p> 
			<p class="fragment roll-in">e.g. Img processing company Implements an interface.
			Graphical application company uses that interface.</p>
			<p class="fragment roll-in">its implementation of the API is kept as a closely guarded secret—in fact, 
			it may revise the implementation at a later date as long as it continues to 
			implement the original interface that its customers have relied on.</p>

</p>
			</section>
			
            
            <section>
				<h3>Summary of interfaces</h3>
				<ol>
				<li>An interface defines a protocol of communication between two objects.</li>
				<li>An interface declaration contains signatures, but no implementations, for a set of methods, and might also contain constant definitions.</li>
				<li>A class that implements an interface must implement all the methods declared in the interface.</li>
				<li>An interface name can be used anywhere a type can be used.</li>
				</ol>
            </section>
            
            
            <section>
				<h3>Questions and Exercises</h3>
				<ol>
				<li>What methods would a class that implements the java.lang.CharSequence interface have to implement?</li>
			
            </section>
            
            <section>
            	<li>What is wrong with the following interface?</li>
			      <pre class="fragment fade-in"><code contenteditable spellcheck="false" class="java">
public interface SomethingIsWrong {
    void aMethod(int aValue){
        System.out.println("Hi Mom");
    }
}

            </code></pre>
			<p class="fragment roll-in">How will you fix this interface?</p>
			</section>
            
            <section>
            <li>Is the following interface valid?</li>
                  <pre class="fragment fade-in"><code contenteditable spellcheck="false" class="java">
public interface Marker {
}
            </code></pre>
			</ol>
            </section>
            
			
			<section>
			<h3>Final Modifier</h3>
			<p>final keyword means this class cannot be subclassed</p>
			   <pre class="fragment fade-in"><code contenteditable spellcheck="false" class="java">
    package cert;
    public final class Fruit{
        public void importantMethod(){ 
             System.out.println("Printing important stuff");
        }
    }   
</code></pre>
            <p> Trying the following will fail - <em class="fragment highlight-red">Compiler error</em></p> 
               <pre class="fragment fade-in"><code contenteditable spellcheck="false" class="java">
    package cert;
    public class Orange extends Fruit{ //NO!!!

    }   
</code></pre>        
			<p>Primary motivation to use a final class is : security and efficiency</p>
			</section>
			
	
			<section>
			<h3>Abstract classes</h3>
			<p class="fragment roll-in">can never be instantiated, it can only be subclassed.</p>
			<pre class="fragment fade-in"><code contenteditable spellcheck="false" class="java">
    package cert;
    abstract class Car{
        private double price;
        private String model;
        public abstract void goFast();//notice the semicolons
        public abstract void stop();//notice the semicolons
    }   
</code></pre>  
	<p class="fragment roll-in">The concrete implementations are provided by concrete subclasses</p>
<pre class="fragment fade-in"><code contenteditable spellcheck="false" class="java">
    package cert;
    public class FiatCar extends Car{
        private double price=50000;
        private String model="Fiat";
        public void goFast(){
            System.out.println("speeding up");
        }
		public void stop(){
            System.out.println("Car stopped");
        } 
    }   
</code></pre>  
			</section>
			
			<section>
			<h3>Interesting facts on interfaces</h3>
			<ul>
			<li class="fragment roll-in">All interfaces are abstract whether typed or not.</li>
			<li class="fragment roll-in">All interface methods are public and abstract whether typed or not.</li>
			<li class="fragment roll-in">All interface constants are public,static and final whether typed or not</li>
			</ul>
			</section>
			
			<section>
			Q and A
			1. can a class be both final and abstract - <p class="fragment fade-in">NO they defeat each others purposes</p>
			
			</section>
			
			<section>
			<h3>Polymorphism and Reference variables</h3>
			<p>Polymorphic- Java objects that pass more than one IS-A test can be considere polymorphic.<br/>
			All java objects pass this test for class java.lang.object and their own type and hence are polymorphic</p>
			<ul>
			<li class="fragment roll-in">A reference variable can be of only one type, and once declared that type can never change</li>
			<li class="fragment roll-in">A reference is a variable so it can be re assigned to other objects</li>
			<li class="fragment roll-in">Invokable methods depend on reference variable type</li>
			<li class="fragment roll-in">Ref variable can refer to object of same type or <em class="fragment highlight-red">any subtype of declared type</em></li>
			<li class="fragment roll-in">Reference var. can be declared as class type or interface, If interface type , it can refer to object of class that implements that interface</li>
			</ul>
	        </section>
			
			<section>
			<h3 class="fragment fade-in">Java supports only single inheritance!!!</h3>
<pre class="fragment fade-in"><code contenteditable spellcheck="false" class="java">
    class PlayerPeice extends GameShape,AnimateShape{ //NO!!!,NO!!!
        //...
    }   
    
</code></pre>
		<p class="fragment roll-in">A class cannot extend more than one class,</p><p class="fragment roll-in">that means only one parent per class</p>	
<pre class="fragment fade-in"><code contenteditable spellcheck="false" class="java">
    class B extends A{ /*OK*/ 
        //...
    }   
    class C extends B{ /*OK*/
        //...
    }
    
</code></pre>
			</section>
	
	<section>
	Gameshape class and PlayerPeice class:
	<pre class="fragment fade-in"><code contenteditable spellcheck="false" class="java">
    class GameShape{
        public void displayShape(){
			System.out.println("display shape");
        }
    }   
    
    public interface Animatable{
        public void animate();
    }
    
    class PlayerPeice extends GameShape implements Animatable{
        public void movePeice(){
            System.out.println("moving peice");
        }
        public void animate(){
            System.out.println("animating peice");
        }
    }
    
</code></pre>
	</section>
	
	<section>
	treated polymorphically as one of four depending upon the type of reference variable:
	<ul>
	<li class="fragment roll-in">An object(since any object inherits from java.Lang.Object)</li>
	<li class="fragment roll-in">A GameShape(since PlayerPeice extends GameShape)</li>
	<li class="fragment roll-in">A PlayerPeice(since that is what it really is)</li>
	<li class="fragment roll-in">An Animatable(since PlayerPeice implements Animatable)</li>
	</ul>
	<br />
	Look at the following legal declarations:
	<pre class="fragment fade-in"><code contenteditable spellcheck="false" class="java">
    PlayerPeice player = new PlayerPeice();
    Object o = player;
    GameShape shape = player;
    Animatable mover = player;
    
</code></pre>
Q - Which two vars can invoke displayShape()?
	</section>
			
			<section>
			<h3>Overriding vs Overloading</h3>
			Overriding : Re-implementing parent class function , exact same function signature(Arg list)
			<br/>
			<pre class="fragment fade-in"><code contenteditable spellcheck="false" class="java">
    class A{  
        public void abc(int a){ ... }
    }   
    class B extends A{ 
        public void abc(int a){ //Here goes the overriden code }
    }
    
</code></pre>
			<br/>
			Overloading : Re use the function name, Must have a different function signature(Arg list)
			<pre class="fragment fade-in"><code contenteditable spellcheck="false" class="java">
    class A{  
        public void abc(int a){ ... }
        public void abc(int a,int b){ ... }
    }   
    
</code></pre>
			</section>
			
			<section>
			<h3>Most important tip on overriding</h3>
			<h2 class="fragment roll-in">Invokable methods depend on ref var, the real method being invoked is of real object's type</h2>
			</section>
			
			<section>
			<h4>Some exercises</h4>
			<pre class="fragment fade-in"><code contenteditable spellcheck="false" class="java">
    class Animal{  
        public void eat(){ 
            System.out.println("Animal eats");    
        }
    }   
    
</code></pre>
<pre class="fragment fade-in"><code contenteditable spellcheck="false" class="java">
    class Horse extends Animal{  
        public void eat(){ 
            System.out.println("Horse eats horse stuff");    
        }
    }   
    
</code></pre>
<pre class="fragment fade-in"><code contenteditable spellcheck="false" class="java">
    public class TestAnimals{
		public static void main(String args[]){  
            Animal a = new Animal();
            Animal b = new Horse(); // Animal ref, Horse object
            a.eat();
            b.eat();
        }
    }   
    
</code></pre>

			</section>
			
			<section>
			<h3>Static</h3>
			Use static variables to hold data that is class specific as opposed to instance specific<br/>
			There will be only one copy of static variable
			In Fact you can use static method or static variable of a class without having any instances 
			of the Class.
			</section>
			
			<section>
			<h4>What would be the output of the following code when run?</h4>
<pre class="fragment fade-in"><code contenteditable spellcheck="false" class="java">
    public class Foo{
		int x = 3;
		public static void main(String args[]){  
            System.out.println("x is "+x);
        }
    }   
    
</code></pre>
<p class="fragment roll-in">The code will not compile!! primarily due to the fact that main is a static context and x is an instance variable</p>
<h4 class="fragemnt roll-in">Effects of static on methods and variables</h4>
<ol>
<li class="fragment roll-in">static method cannot access an instance(non-static) variable</li>
<li class="fragment roll-in">static method cannot access an instance(non-static) method</li>
<li class="fragment roll-in">static method can access static methods and variables</li>
</ol>
			</section>
			
			<section>
			Nested Classes, inner classes and Anonymous inner classes
			</section>
            
<section> 
<h3>Regular inner classes</h3>
<h6>are classes which are </h6>
<ul>
<li class="fragment roll-in">not Static</li> 
<li class="fragment roll-in">not Method local (i.e not declared inside a method)</li>
<li class="fragment roll-in">not Anonymous(should have a name)</li>  
</ul>
<p class="fragment roll-in">TIP : inner classes are members of the outer class just like variables
    and methods are members of the outer class</p>
 </section>


 <section> 
<h4>Coding a Regular inner classes</h4>
<pre class="fragment fade-in"><code contenteditable spellcheck="false" class="java">
    class MyOuter {
        class MyInner{

        }
    }
</code></pre>
<pre class="fragment fade-in"><code contenteditable spellcheck="false" class="java">
    $javac MyOuter.java 
</code></pre>
<p class="fragment roll-in">Compiling it You will end up with MyOuter.class and MyOuter$MyInner.class</p>
  </section>

<section> 
<h4> Q and A </h4>
<h5> Is this peice of code legal ? </h5>
<pre class="fragment fade-in"><code contenteditable spellcheck="false" class="java">
    class MyOuter { 
        private int x = 7;//private variable
        class MyInner{
            public void seeOuter(){
                System.out.println("Outer x is "+x);
            }
        }//close inner class def
    }//close outer class def
</code></pre>
<p class="fragment roll-in">Yes it is! Remember the tip earlier? This inner class is just like a member instance method or member variable</p>
 </section>

<section> 
<h4>TIP: <i>The only way you can access the inner class is through a live instance of outer class</i></h4>
<h5> Instantiating an inner class </h5>
<ul>
<li class="fragment roll-in">Instantiating an Inner class from within the outer class</li>
<li class="fragment roll-in">Creating an Inner class object from Outside the Outer class</li>  
</ul>
 </section>

<section> 
<p>Instantiating an Inner class from within the outer class</p>
<p class="fragment roll-in">Most often it is the outer class that instantiates the inner class using it as a helper</p>
<pre class="fragment fade-in"><code contenteditable spellcheck="false" class="java">
    class MyClass { 
        private int x = 7;
        public void makeInner(){
            MyInner in = new MyInner(); // see this : outer class instatiates  inner
            in.seeOuter();
        }

        class MyInner{
            public void seeOuter(){
                System.out.println("Outer x is "+x);
            }
        }
    }
</code></pre>
 </section>

 <section> 
    Creating an Inner class object from Outside the Outer class
<pre class="fragment fade-in"><code contenteditable spellcheck="false" class="java">
    class SomeOtherClassInSamePackageAsMyOuter { 
        public static void main(String args[]){
            MyOuter mo = new MyOuter(); //gotta get an instance, remember the previous tip?
            MyOuter.MyInner inner = mo.new MyInner();
            inner.seeOuter();
        }
    }
</code></pre>
<p class="fragment roll-in">Or if you are into one liners</p>
<pre class="fragment fade-in"><code contenteditable spellcheck="false" class="java">
    class SomeOtherClassInSamePackageAsMyOuter { 
        public static void main(String args[]){
            MyOuter.MyInner inner = new MyOuter().new MyInner();
            inner.seeOuter();
        }
    }
</code></pre>
  </section>

<section> 
<h3>Inner classes and the keyword 'this'</h3>
<ul>
<li class="fragment roll-in">In the inner class code you can refer to the inner class instance object as 'this'
</li>
<li class="fragment roll-in">In the inner class code you can refer to outer enclosing class as MyOuter.this</li>  
</ul>
 </section>



  <section> 
<h3> Method local inner classes </h3>
<p class="fragment roll-in">these classes are declared inside methods, regular inner classes are declared outside any method</p>
<pre class="fragment fade-in"><code contenteditable spellcheck="false" class="java">
    class MyOuter { 
        private String x="outer";

        void doStuff(){
            class MyInner{
                public void seeOuter(){
                    System.out.println("outer x is "+x);
                }
            }
            MyInner in = new MyInner();
            in.seeOuter();
        }
    }

</code></pre>
   </section>

<section> 
<h4>More on Method local inner class</h4>
<ul>
<li class="fragment roll-in">A method local inner class can be instantiated only within the method where the inner class is defined</li>
<li class="fragment roll-in"> No other code running in any other method - inside or outside the class, can ever instantiate the method-local inner class</li>
<li class="fragment roll-in"></li>   
</ul>
</section>


<section> 
<h3> Anonymous Inner classes </h3>
<pre class="fragment fade-in"><code contenteditable spellcheck="false" class="java">
    class MyClass { 
        public void myMethod(){
            System.out.println("myMethod");
        }
    }
    class OtherClass{
        MyClass m = new MyClass(){
            public void myMethod(){
                System.out.println("overriden myMethod");
            }
        };//note the semicolon
        m.myMethod();
    }
</code></pre>
 </section>

 <section>
<h3> Static nested classes </h3>
<p>A static nested class is simply a class that is a static member of the enclosing class</p>
<p class="fragment roll-in"> This means it can be accessed, as with other static members, without having an instance of the outer class</p>
<pre class="fragment fade-in"><code contenteditable spellcheck="false" class="java">
    class BigOuter {
        static class Nest{
            void go() { System.out.println("hi");}
        }   
    }
    
    class Other{
        public static void main(String args[]){
            BigOuter.Nest n = new BigOuter.Nest();
            n.go();
        }
    }

</code></pre>
</section>

<section>
<h4>Enum Types</h4>
An enum type is a special data type that enables for a variable to be a set of predefined constants.
<p>you need to represent a <em class="fragment highlight-red">fixed set of constants</em></p>
<pre class="fragment fade-in"><code contenteditable spellcheck="false" class="java">
    public enum Day {
        SUNDAY, MONDAY, TUESDAY, WEDNESDAY,
        THURSDAY, FRIDAY, SATURDAY 
    }
	
</code></pre>
<p class="fragment roll-in">Iterating through an enum</p>
<pre class="fragment fade-in"><code contenteditable spellcheck="false" class="java">
    for (Day d : Day.values()) {
        // do what you want
    }
	
</code></pre>

</section>

            

            <section>
                <h2>Thank You</h2>
				<h1>Questions?</h1>
				
            </section>
            </div>
    </div>
	<footer style="display:none;">
        <div style="float:left;">
		<img src="images/samsung-logo.jpg" />
		Samsung Electronics  {{ CURRENT_SLIDE }} of {{ NUM_SLIDES }}</div>
      </footer>
    <script src="reveal.js-master/lib/js/head.min.js"></script>
    <script src="reveal.js-master/js/reveal.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
    <script>
        // Required, even if empty.
        Reveal.initialize({
        
       dependencies: [
        
          {
            src: 'footer.reveal.js',
            condition: function() { return !!document.querySelector( 'footer' ); } 
          }
        
        ]
		
	   
	

    //    autoSlide: 5000

        });
    </script>

</body>
</html>
